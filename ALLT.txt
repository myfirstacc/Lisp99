____________________________________________________________ 1&2

Find the last box of a list. Find the last but one box of a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist &optional (rest 0))
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)
    
(setq mylist (list 0 4 9 4 41))
(setq newlist (LastNC mylist 2))
(print newlist)

_____________________________________________________________ 3

Find the K'th element of a list. 

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)
    
(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(setq mylist (list 0 3 9 4 41))
(setq K (KEL mylist 1))
(print K)
_____________________________________________________________ 4

Find the number of elements of a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(setq mylist (list 0 3 9 4 41))
(setq len (ListLength mylist))
(print len)

_____________________________________________________________ 5

Reverse a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun ReverseList (somelist &optional (counter (ListLength somelist)) (revlist (list)))
    (if (= counter 0)
        (return-from ReverseList revlist)
        (progn
            (setq revlist (append revlist (list (KEL somelist counter))))
            (ReverseList somelist (- counter 1) revlist)
        )
    )
)


(setq mylist (list 0 3 9 4 41))
(print mylist)
(setq mylist (ReverseList mylist))
(print mylist)

_____________________________________________________________ 6

Find out whether a list is a palindrome.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ numofel 1))
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun IsPalindrom (somelist &optional (len (ListLength somelist)) (checknums 1))
    (if (eq (KEL somelist checknums) (KEL somelist (+ (- len checknums) 1)))
        (if (>= (+ (mod 2 checknums) 1) (/ len 2))
            (return-from IsPalindrom 1)
            (IsPalindrom somelist len (+ checknums 1))
        )
        (return-from IsPalindrom 0)
    )
)
(setq mylist (list 1 2 2 5 5 1 5 5 2 2 1))
(print (isPalindrom mylist))

_____________________________________________________________ 7

Transform a list, possibly holding lists as elements into a `flat' list by replacing each list with its elements (recursively).

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ numofel 1))
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun MakeFlatList (somelist &optional (elnum 1) (flist (list)))
    (if (> elnum (ListLength somelist))
        (return-from MakeFlatList flist)
        (progn    
            (setq currentel (KEL somelist elnum))
            (if (listp currentel)
                (progn
                    (setq i 1)
                    (setq len (ListLength currentel))
                    (loop
                        (setq flist (append flist (list (KEL currentel i))))
                        (setq i (+ i 1))
                        (when (= i (+ len 1)) (return flist))
                    )
                    (MakeFlatList somelist (+ elnum 1) flist)
                )
                (progn
                    (setq flist (append flist (list currentel)))
                    (print flist)
                    (MakeFlatList somelist (+ elnum 1) flist)
                )
            )
        )
    )
)
        

(setq myhardlist (list 1 4 (list 4 6)))
(print myhardlist)
(setq myhardlist (MakeFlatList myhardlist))
(print myhardlist)
______________________________________________________________ 8

If a list contains repeated elements they should be replaced with a single copy of the element. The order of the elements should not be changed.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist rest )
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun FirstRepEl (somelist &optional (hm 1))
    (if (eq (KEL somelist hm) (KEL somelist (+ hm 1)))
        (FirstRepEl somelist (+ hm 1))
        (return-from FirstRepEl hm)
    )
)

(defun RemoveRep (somelist &optional (wiorep (list)) (index (ListLength somelist)))
    (if (= index 0)
	(return-from RemoveRep wiorep)
	(progn
	    (setq somelist (LastNC somelist index))
	    (setq wiorep (append wiorep (list (car somelist))))
	    (RemoveRep somelist wiorep (- index (FirstRepEl somelist)))
	)
    )
)	

(setq mylist '(a a a b b c c c c d))
(print (RemoveRep mylist))

______________________________________________________________ 9 

If a list contains repeated elements they should be placed in separate sublists.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun PlaceIntoSubt (somelist &optional (newlist (list)) (sml (list)) (currel (KEL somelist 1)) (tr 1) (index 1))
    (if (> index (ListLength somelist))
        (return-from PlaceIntoSubt newlist)
        (if (eql currel (KEL somelist (+ index 1)))
            (PlaceIntoSubt somelist newlist (list ) currel (+ tr 1) (+ index 1))
            (progn
                (loop
                    (setq sml (append sml (list currel)))
                    (setq tr (- tr 1))
                    (when (< tr 1) (return sml))
                )
                (setq newlist (append newlist (list sml)))
                (PlaceIntoSubt somelist newlist (list ) (KEL somelist (+ index 1)) 1 (+ index 1))
            )
        )
    )
)

(setq mylist (list 'a 'a 'a 'b 'c 'zz 'zz 'a 'a 'zz))
(print (PlaceIntoSubt mylist))
______________________________________________________________ 10&11

Use the result of problem P09 to implement the so-called run-length encoding data compression method. Consecutive duplicates of elements are encoded as lists (N E) where N is the number of duplicates of the element E.
Modify the result of problem P10 in such a way that if an element has no duplicates it is simply copied into the result list. Only elements with duplicates are transferred as (N E) lists.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun FirstRepEl (somelist &optional (hm 1))
    (if (eq (KEL somelist hm) (KEL somelist (+ hm 1)))
        (FirstRepEl somelist (+ hm 1))
        (return-from FirstRepEl hm)
    )
)

(defun NEnc (somelist &optional (enc (list)) (index (ListLength somelist)))
    (if (= index 0)
	(return-from NEnc enc)
	(progn
	    (setq somelist (LastNC somelist index))
	    (setq enc (append enc (list (append (list (FirstRepEl somelist)) (list (car somelist))))))
	    (NEnc somelist enc (- index (FirstRepEl somelist)))
	)
    )
)	

(defun ModNEnc (somelist &optional (enc (list)) (index (ListLength somelist)))
    (if (= index 0)
        (return-from ModNEnc enc)
        (progn
            (setq somelist (LastNC somelist index))
            (if (= (FirstRepEl somelist) 1)
                (progn
                    (setq enc (append enc (list (car somelist))))
                    (ModNEnc somelist enc (- index (FirstRepEl somelist)))
                )
                (progn 
                    (setq enc (append enc (list (append (list (FirstRepEl somelist)) (list (car somelist))))))
                    (ModNEnc somelist enc (- index (FirstRepEl somelist)))
                )
            )
        )
    )
)	

(setq mylist '(a a a b b c c c c d))
(print (NEnc mylist))
(print (ModNEnc mylist))

______________________________________________________________ 12

Given a run-length code list generated as specified in problem P11. Construct its uncompressed version.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun LDecoding (somelist &optional (index 1) (declist (list)))
    (if (> index (ListLength somelist))
        (return-from LDecoding newlist)
        (progn
            (setq hp (KEL somelist index))
            (if (not (listp hp))
                (LDecoding somelist (+ index 1) (append declist (list hp)))
                (progn
                    (setq decpart (list))
                    (setq repel (KEL hp 2))
                    (loop for i from 1 to (KEL hp 1)
                          do (setq decpart (append decpart (list repel)))
                    )
                    (LDecoding somelist (+ index 1) (append declist decpart))
                )
            )
        )
    )
)
(setq mylist (list '(3 G) 'B '(5 a)))
(print mylist)
(setq mylist (LDecoding mylist))
(print mylist)

______________________________________________________________ 13 What is the task (probably solution of task 9 is correct)

Implement the so-called run-length encoding data compression method directly. I.e. don't explicitly create the sublists containing the duplicates, as in problem P09, but only count them. As in problem P11, simplify the result list by replacing the singleton lists (1 X) by X.


















_______________________________________________________________ 14&15

Duplicate the elements of a list. Replicate the elements of a list a given number of times.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)
    
(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun Dupli (somelist &optional (dlist (list)) (index 1))
    (if (> index (ListLength somelist))
        (return-from Dupli dlist)
        (progn
            (setq currel (KEL somelist index))
            (setq dlist (append dlist (list currel currel)))
            (Dupli somelist dlist (+ index 1))
        )
    )
)

(defun Repli (somelist hm &optional (rlist (list)) (index 1))
    (if (> index (ListLength somelist))
        (return-from Repli rlist)
        (progn
            (setq currel (KEL somelist index))
            (setq i 0)
            (loop 
                (setq rlist (append rlist (list currel)))
                (setq i (+ i 1))
                (when (= i hm) (return rlist))
            )
            (Repli somelist hm rlist (+ index 1))
        )
    )
)

(setq mylist (list 1 4 5 'a))
(print (Dupli mylist))
(print (Repli mylist 5))

_______________________________________________________________ 16

Drop every N'th element from a list. 

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ numofel 1))
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun DropEls (somelist index &optional (newlist (list))(counter 1) (len (ListLength somelist)))
    (if (> counter len)
        (return-from DropEls newlist)
        (if (= (mod counter index) 0)
            (DropEls somelist index newlist (+ counter 1) len)
            (progn
                (setq newlist (append newlist (list (KEL somelist counter))))
                (DropEls somelist index newlist (+ counter 1) len)
            )
        )
    )
)

(setq mylist (list 1 4 5 6 1 'a 'c 4 9 -1))
(print (DropEls mylist 4))

______________________________________________________________ 17 

Split a list into two parts; the length of the first part is given.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun FirstNC (somelist amount &optional (newlist (list))(index 1))
    (if (> index amount)
        (return-from FirstNC newlist)
        (progn
            (setq newlist (append newlist (list (KEL somelist index))))
            (FirstNC somelist amount newlist (+ index 1))
        )
    )
)

(defun Split (somelist fpl &optional (newlist (list)))
    (setq newlist (append newlist (list (FirstNC somelist fpl)) (list (LastNC somelist (- (ListLength somelist) fpl)))))
    (return-from Split newlist)
)

______________________________________________________________ 18

Given two indices, I and K, the slice is the list containing the elements between the I'th and K'th element of the original list (both limits included). Start counting the elements with 1.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ numofel 1))
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun Slice (somelist mil mal &optional (newlist (list)) (index 1))
    (if (> index mal)
        (return-from Slice newlist)
        (progn
            (if (>= index mil)
                (progn
                    (setq newlist (append newlist (list (KEL somelist index))))
                    (Slice somelist mil mal newlist (+ index 1))
                )
                (Slice somelist mil mal newlist (+ index 1))
            )
        )
    )
)

(setq mylist (list 1 2 3 4 5 6 7 8 9))
(print mylist)
(print (Slice mylist 4 7))

______________________________________________________________ 19 

Rotate a list N places to the left.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun FirstNC (somelist amount &optional (newlist (list))(index 1))
    (if (> index amount)
        (return-from FirstNC newlist)
        (progn
            (setq newlist (append newlist (list (KEL somelist index))))
            (FirstNC somelist amount newlist (+ index 1))
        )
    )
)

(defun RotateOn (somelist rn &optional (newlist (list)))
    (setq newlist (append newlist (LastNC somelist (- (ListLength somelist) rn)) (FirstNC somelist rn)))
    (return-from RotateOn newlist)
)

(setq mylist (list 1 2 3 4 5 6 7 8))
(print mylist)
(print (RotateOn mylist 3))

______________________________________________________________ 20 

Remove the K'th element from a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun FirstNC (somelist amount &optional (newlist (list))(index 1))
    (if (> index amount)
        (return-from FirstNC newlist)
        (progn
            (setq newlist (append newlist (list (KEL somelist index))))
            (FirstNC somelist amount newlist (+ index 1))
        )
    )
)

(defun RemoveNEl (somelist pos &optional (newlist (list)))
    (setq newlist (append newlist (FirstNC somelist (- pos 1)) (LastNC somelist pos)))
    (return-from RemoveNEl newlist)
)
                          
(setq mylist (list 1 2 3 4 5 6 7 8))
(print mylist)
(print (RemoveNEl mylist 4))

______________________________________________________________ 21

Insert an element at a given position into a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun FirstNC (somelist amount &optional (newlist (list))(index 1))
    (if (> index amount)
        (return-from FirstNC newlist)
        (progn
            (setq newlist (append newlist (list (KEL somelist index))))
            (FirstNC somelist amount newlist (+ index 1))
        )
    )
)

(defun InsertIn (somelist elem pos)
    (setq somelist (append (FirstNC somelist (- pos 1)) (list elem) (LastNC somelist (- (+ (ListLength somelist) 1) pos))))
    (return-from InsertIn somelist)
)

(setq mylist (list 1 2 3 4 5 6 7))
(print mylist)
(print (InsertIn mylist 'alfa 1))

_______________________________________________________________ 22

Create a list containing all integers within a given range.

(defun InRange (min max &optional (newlist (list)))
    (if (> min max)
        (return-from InRange newlist)
        (progn
            (setq newlist (append newlist (list min)))
            (InRange (+ min 1) max newlist)
        )
    )
)

(setq mylist (InRange 1 9))
(print mylist)

_______________________________________________________________ 23

Extract a given number of randomly selected elements from a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)
    
(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun FirstNC (somelist amount &optional (newlist (list))(index 1))
    (if (> index amount)
        (return-from FirstNC newlist)
        (progn
            (setq newlist (append newlist (list (KEL somelist index))))
            (FirstNC somelist amount newlist (+ index 1))
        )
    )
)

(defun RemoveNEl (somelist pos &optional (newlist (list)))
    (setq newlist (append newlist (FirstNC somelist (- pos 1)) (LastNC somelist (- (ListLength somelist) pos))))
    (return-from RemoveNEl newlist)
)

(defun RandomExtract (somelist times &optional (newlist (list)) (rndst (make-random-state)) (len (ListLength somelist)))
    (if (= times 0)
        (return-from RandomExtract newlist)
        (progn
            (setq rndst (make-random-state t))
            (setq rnum (+ (random len rndst) 1))
            (setq newlist (append newlist (list (KEL somelist rnum))))
            (setq somelist (RemoveNEl somelist rnum))
            (RandomExtract somelist (- times 1) newlist rndst)
        )
    )
)

(setq mylist (list 1 2 'a 'b 'zz))
(print (RandomExtract mylist 4))

______________________________________________________________ 24

Draw N different random numbers from the set 1..M.

(defun CreateRList (nums upl &optional crlist (rndst (make-random-state)))
    (if (= nums 0)
        (return-from CreateRList crlist)
        (progn
            (setq rndst (make-random-state t))
            (setq rnum (+ (random upl rndst) 1))
            (setq crlist (append crlist (list rnum)))
            (CreateRList (- nums 1) upl crlist rndst)
        )
    )
)

(setq mylist (CreateRList 9 49))
(print mylist)

______________________________________________________________ 25

Generate a random permutation of the elements of a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)
    
(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun FirstNC (somelist amount &optional (newlist (list))(index 1))
    (if (> index amount)
        (return-from FirstNC newlist)
        (progn
            (setq newlist (append newlist (list (KEL somelist index))))
            (FirstNC somelist amount newlist (+ index 1))
        )
    )
)

(defun RemoveNEl (somelist pos &optional (newlist (list)))
    (setq newlist (append newlist (FirstNC somelist (- pos 1)) (LastNC somelist (- (ListLength somelist) pos))))
    (return-from RemoveNEl newlist)
)

(defun RandomPerm (somelist &optional (times (ListLength somelist)) (newlist (list)) (rndst (make-random-state)))
    (if (= times 0)
        (return-from RandomPerm newlist)
        (progn
            (setq rndst (make-random-state t))
            (setq rnum (+ (random (ListLength somelist) rndst) 1))
            (setq newlist (append newlist (list (KEL somelist rnum))))
            (setq somelist (RemoveNEl somelist rnum))
            (RandomPerm somelist (- times 1) newlist rndst)
        )
    )
)

(setq mylist (list 1 2 'a 'b 'zz))
(print (RandomPerm mylist 5))

________________________________________________________________ 26 Not Correct - Result is a number of possible combinations

In how many ways can a committee of 3 be chosen from a group of 12 people? We all know that there are C(12,3) = 220 possibilities (C(N,K) denotes the well-known binomial coefficients). For pure mathematicians, this result may be great. But we want to really generate all the possibilities in a list.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun Factorial (num)
    (if (<= num 1)
        (return-from Factorial 1)
        (return-from Factorial (* num (Factorial (- num 1))))
    )
)

(defun CombAmount (somelist loc)
    (setq len (ListLength somelist))
    (setq comb (/ (Factorial len) (* (Factorial loc) (Factorial (-  len loc)))))
    (return-from CombAmount comb)
)

(setq mylist (list 'a 'b 'c 'd 'e 'f))
(print (CombAmount mylist 2))

________________________________________________________________ 27

In how many ways can a group of 9 people work in 3 disjoint subgroups of 2, 3 and 4 persons? Write a function that generates all the possibilities and returns them in a list.
Generalize the above predicate in a way that we can specify a list of group sizes and the predicate will return a list of groups.




















______________________________________________________________ 28 Second part is not finished

We suppose that a list contains elements that are lists themselves. The objective is to sort the elements of this list according to their length. E.g. short lists first, longer lists later, or vice versa.
Again, we suppose that a list contains elements that are lists themselves. But this time the objective is to sort the elements of this list according to their length frequency; i.e., in the default, where sorting is done ascendingly, lists with rare lengths are placed first, others with a more frequent length come later.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun LastNC (somelist rest)
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun FirstNC (somelist amount &optional (newlist (list))(index 1))
    (if (> index amount)
        (return-from FirstNC newlist)
        (progn
            (setq newlist (append newlist (list (KEL somelist index))))
            (FirstNC somelist amount newlist (+ index 1))
        )
    )
)

(defun RemoveNEl (somelist pos &optional (newlist (list)))
    (setq newlist (append newlist (FirstNC somelist (- pos 1)) (LastNC somelist (- (ListLength somelist) pos))))
    (return-from RemoveNEl newlist)
)

(defun InsertIn (somelist elem pos)
    (setq somelist (append (FirstNC somelist (- pos 1)) (list elem) (LastNC somelist (- (+ (ListLength somelist) 1) pos))))
    (return-from InsertIn somelist)
)

(defun LLTransform (somelist &optional (newlist (list)) (index 1))
    (if (> index (ListLength somelist))
        (return-from LLTransform newlist)
        (progn
            (setq newlist (append newlist (list (ListLength (KEL somelist index)))))
            (LLTransform somelist newlist (+ index 1))
        )
    )
)

(defun LSort (somelist &optional (trlist (LLTransform somelist)) (index 1) (hpv 1))
    (if (> index (ListLength somelist))
        (return-from LSort somelist)
        (progn
            (if (= hpv (ListLength somelist))
                (progn
                    (setq hpv 1)
                    (setq index (+ index 1))
                )
                (princ "")
            )
            (if (> (KEL trlist hpv) (KEL trlist (+ hpv 1)))
                (progn
                    (setq somelist (InsertIn somelist (KEL somelist hpv) (+ hpv 2)))
                    (setq somelist (RemoveNEl somelist hpv))
                )
                (princ "")
            )
            (LSort somelist (LLTransform somelist) index (+ hpv 1))
        )
    )
)

(defun AreIn (somelist condv &optional (index 1))
    (if (> index (ListLength somelist))
        (return-from AreIn 0)
        (if (equal (KEL somelist index) condv)
            (return-from AreIn 1)
            (AreIn somelist condv (+ index 1))
        )
    )
)

(defun LFTransform (somelist &optional (newlist (list )) (trlist (LLTransform somelist)) (index (ListLength somelist)) (currel (KEL trlist 1)) (counter 0) (hpv 1))
    (if (= index 0)
        (return-from LFTransform newlist)
        (if (= (AreIn trlist currel) 1)
            (progn
                (if (= (KEL trlist hpv) currel)
                    (progn
                        (setq trlist (RemoveNEl trlist hpv))
                        (setq counter (+ counter 1))
                    )
                )
                (if (> (+ hpv 1) (ListLength trlist))
                    (setq hpv 1)
                    (setq hpv (+ hpv 1))
                )
                (LFTransform somelist newlist trlist index currel counter hpv)
            )
            (progn
                (setq newlist (append newlist (list (list counter currel))))
                (if (null trlist)
                    (return-from LFTransform newlist)
                    (progn
                        (setq index (- index 1))
                        (setq counter 0)
                        (setq hpv 1)
                        (setq currel (KEL trlist hpv))
                        (LFTransform somelist newlist trlist index currel counter hpv)
                    )
                )
            )
        )
    )
)

(setq mylist (list (list 'a 'b) (list 'zaz) (list 'c 'd 'e) (list 'z 'z) (list 'boo) (list 'b 'b 'b 'b) (list 'p) (list 'a 'v 'd 'g)))
(print mylist)
(print (LLTransform mylist))
(print (LFTransform mylist))
______________________________________________________________ 31

Determine whether a given integer number is prime.

(defun IsPrime (num &optional (index 2))
    (if (>= index num)
        (return-from IsPrime 1)
        (if (= (rem num index) 0)
            (return-from IsPrime 0)
            (IsPrime num (+ index 1))
        )
    )
)
(setq num 7)
(print (IsPrime num))
____________________________________________________________________ 32&33

Determine the greatest common divisor of two positive integer numbers. Determine whether two positive integer numbers are coprime.

(defun GCD (x y)
    (if (= (rem x y) 0)
        (return-from GCD y)
        (GCD y (rem x y))
    )
)
(defun IsCoprime (x y)
    (if (= (GCD x y) 1)
        (return-from IsCoprime 1)
        (return-from IsCoprime 0)
    )
)
(setq num1 21)
(setq num2 14)
(print (IsCoprime num1 num2))
____________________________________________________________________ 34

Calculate Euler's totient function phi(m). Euler's so-called totient function phi(m) is defined as the number of positive integers r (1 <= r < m) that are coprime to m.

(defun GCD (x y)
    (if (= (rem x y) 0)
        (return-from GCD y)
        (GCD y (rem x y))
    )
)
(defun IsCoprime (x y)
    (if (= (GCD x y) 1)
        (return-from IsCoprime 1)
        (return-from IsCoprime 0)
    )
)

(defun Phi (num &optional (thephi 1) (currnum 2))
    (if (= num currnum)
        (return-from Phi thephi)
        (if (= (IsCoprime num currnum) 1)
            (Phi num (+ thephi 1) (+ currnum 1))
            (Phi num thephi (+ currnum 1))
        )
    )
)
(setq somenum 11)
(print (Phi somenum))
____________________________________________________________________ 35

Determine the prime factors of a given positive integer. Construct a flat list containing the prime factors in ascending order.

(defun PrimeFlist (num &optional (fact 2) (crlist (list 1)))
    (if (= num 1)
        (return-from PrimeFlist crlist)
        (if (= (rem num fact) 0)
            (PrimeFlist (/ num fact) fact (append crlist (list fact)))
            (PrimeFlist num (+ fact 1) crlist)
        )
    )
)
(setq num 315)
(setq prfactlist (PrimeFlist num))
(print prfactlist)
____________________________________________________________________ 36

Determine the prime factors of a given positive integer.
Construct a list containing the prime factors and their multiplicity.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun LastNC (somelist &optional (rest 0))
    (if (= (ListLength somelist) rest)
        (return-from LastNC somelist)
        (LastNC (cdr somelist) rest)
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun FirstRepEl (somelist &optional (hm 1))
    (if (eq (KEL somelist hm) (KEL somelist (+ hm 1)))
        (FirstRepEl somelist (+ hm 1))
        (return-from FirstRepEl hm)
    )
)

(defun NEnc (somelist &optional (enc (list)) (index (ListLength somelist)))
    (if (= index 0)
	(return-from NEnc enc)
	(progn
	    (setq somelist (LastNC somelist index))
	    (setq enc (append enc (list (append (list (car somelist)) (list (FirstRepEl somelist))))))
	    (NEnc somelist enc (- index (FirstRepEl somelist)))
	)
    )
)

(defun PrimeFlist (num &optional (fact 2) (crlist (list 1)))
    (if (= num 1)
        (return-from PrimeFlist crlist)
        (if (= (rem num fact) 0)
            (PrimeFlist (/ num fact) fact (append crlist (list fact)))
            (PrimeFlist num (+ fact 1) crlist)
        )
    )
)
(setq num 315)
(setq prfactlist (PrimeFlist num))
(print prfactlist)

____________________________________________________________________ 37 Wrong Algorithm

Calculate Euler's totient function phi(m) (improved).
phi(m) = (p1 - 1) * p1 ** (m1 - 1) + (p2 - 1) * p2 ** (m2 - 1) + (p3 - 1) * p3 ** (m3 - 1) + ...

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun ModPhi (somelist &optional (index 1) (thephi 0))
    (if (> index (ListLength somelist))
        (return-from ModPhi thephi)
        (and
            (setq currpair (KEL somelist index))
            (setq thephi (+ thephi (* (- (KEL currpair 1) 1) (expt (KEL currpair 1) (- (KEL currpair 2) 1)))))
            (ModPhi somelist (+ index 1) thephi)
        )
    )
)
____________________________________________________________________ 38 Wrong Algorithm In Task 37

Use the solutions of problems P34 and P37 to compare the algorithms. Take the number of logical inferences as a measure for efficiency.








____________________________________________________________________ 39

Given a range of integers by its lower and upper limit, construct a list of all prime numbers in that range.

(defun IsPrime (num &optional (index 2))
    (if (>= index num)
        (return-from IsPrime 1)
        (if (= (rem num index) 0)
            (return-from IsPrime 0)
            (IsPrime num (+ index 1))
        )
    )
)
(defun AllPrimesIn (min max &optional (crlist (list)))
    (if (> min max)
        (return-from AllPrimesIn crlist)
        (if (= (IsPrime min) 1)
            (AllPrimesIn (+ min 1) max (append crlist (list min)))
            (AllPrimesIn (+ min 1) max crlist)
        )
    )
)  
(setq min 3)
(setq max 17)
(print (AllPrimesIn min max))
_____________________________________________________________________ 40&41

Goldbach's conjecture says that every positive even number greater than 2 is the sum of two prime numbers.
Given a range of integers by its lower and upper limit, print a list of all even numbers and their Goldbach composition.

(defun ListLength (somelist &optional (numofel 0))
    (if (null somelist)
        (return-from ListLength numofel)
        (ListLength (cdr somelist) (+ 1 numofel)) 
    )
)

(defun KEL (somelist itsnum &optional (len (ListLength somelist)) (condnum (ListLength somelist)))
    (if (= (+ (- condnum itsnum) 1) len)
        (return-from KEL (car somelist))
        (KEL (cdr somelist) itsnum (- len 1) condnum)
    )
)

(defun IsPrime (num &optional (index 2))
    (if (>= index num)
        (return-from IsPrime 1)
        (if (= (rem num index) 0)
            (return-from IsPrime 0)
            (IsPrime num (+ index 1))
        )
    )
)

(defun LargestPrime (num &optional (index 1) (max 1))
    (if (> index num)
        (return-from LargestPrime max)
        (progn
            (if (= (IsPrime index) 1)
                (LargestPrime num (+ index 1) index)
                (LargestPrime num (+ index 1) max)
            )
        )
    )
)

(defun GoldFunc (num)
    (if (= (rem num 2) 0)
        (progn
            (setq lprime (LargestPrime num))
            (setq goldlist (list (- num lprime) lprime))
            (return-from GoldFunc goldlist)
        )
        (return-from GoldFunc (list ))
    )
)

(defun GoldList (min max &optional (limit 0))
    (if (> min max)
        (princ "end")
        (progn
            (if (= (rem min 2) 0)
                (progn
                    (setq lp (KEL (GoldFunc min) 1))
                    (setq hp (KEL (GoldFunc min) 2))
                    (if (> lp limit)
                        (format t "~D = ~D + ~D~%" min lp hp)
                        (princ "")
                    )
                )
                (princ "")
            )
            (GoldList (+ min 1) max limit)
        )
    )
)

;(print (GoldFunc 28))
(GoldList 7 20)

__________________________________________________________________ 46

Define predicates and/2, or/2, nand/2, nor/2, xor/2, impl/2 and equ/2 (for logical equivalence).
Now, write a predicate table/3 which prints the truth table of a given logical expression in two variables.

(defun andf (A B)
    (if (= A 0)
        (return-from andf 0)
        (if (= B 0)
            (return-from andf 0)
            (return-from andf 1)
        )
    )
)

(defun orf (A B)
    (if (= A 0)
        (if (= B 0)
            (return-from orf 0)
            (return-from orf 1)
        )
        (return-from orf 1)
    )
)

(defun nandf (A B)
    (if (= (andf A B) 0)
        (return-from nandf 1)
        (return-from nandf 0)
    )
)

(defun norf (A B)
    (if (= (orf A B) 0)
        (return-from norf 1)
        (return-from norf 0)
    )
)

(defun xorf (A B)
    (if (= A 0)
        (if (= B 0)
            (return-from xorf 0)
            (return-from xorf 1)
        )
        (if (= B 0)
            (return-from xorf 1)
            (return-from xorf 0)
        )
    )
)

(defun implf (A B)
    (if (= B 0)
        (if (= A 0)
            (return-from implf 1)
            (return-from implf 0)
        )
        (return-from implf 1)
    )
)

(defun equf (A B)
    (if (= A 0)
        (if (= B 0)
            (return-from equf 1)
            (return-from equf 0)
        )
        (if (= B 0)
            (return-from equf 0)
            (return-from equf 1)
        )
    )
)

__________________________________________________________________ 47

Continue problem P46 by defining and/2, or/2, etc as being operators. This allows to write the logical expression in the more natural way, as in the example: A and (A or not B).











__________________________________________________________________ 48

Generalize problem P47 in such a way that the logical expression may contain any number of logical variables.












__________________________________________________________________ 49 Not Correct - In result elements are not lists

An n-bit Gray code is a sequence of n-bit strings constructed according to certain rules. For example,
n = 1: C(1) = ['0','1'].

(defun Pow (num power &optional (hn num))
    (if (= power 0)
        (return-from Pow 1)
        (if (> power 1)
            (Pow (* num hn) (- power 1) hn)
            (if (= power 1)
                (return-from Pow num)
                (if (= power -1)
                    (return-from Pow (/ 1 num))
                    (Pow (* num hn) (+ power 1) hn)
                )
            )
        )
    )
)

(defun Transform (num &optional (trn 0) (index 0))            
    (if (< num 1)
        (return-from Transform trn)
        (progn
            (setq trn (+ trn (* (rem num 2) (Pow 10 index))))
            (Transform (floor num 2) trn (+ index 1))
        )
    )
)
    
(defun GrayFunc (num &optional (index 0)(bit (Pow 2 num))(crlist (list)))
    (if (> index num)
        (return-from GrayFunc crlist)
        (progn
            (setq crlist (append crlist (list (Transform index))))
            (GrayFunc num (+ index 1) bit crlist)
        )
    )
)

(setq mylist (list))
(setq mynum 100)
(setq mylist (GrayFunc mynum))
(print mylist)

_______________________________________________________________________ 50

We suppose a set of symbols with their frequencies, given as a list of fr(S,F) terms. Example: [fr(a,45),fr(b,13),fr(c,12),fr(d,16),fr(e,9),fr(f,5)]. Our objective is to construct a list hc(S,C) terms, where C is the Huffman code word for the symbol S. In our example, the result could be Hs = [hc(a,'0'), hc(b,'101'), hc(c,'100'), hc(d,'111'), hc(e,'1101'), hc(f,'1100')] [hc(a,'01'),...etc.]
